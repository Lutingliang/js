<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 函数的四种调用模式

      // 1. 函数调用模式 this ==> window
      //   function fn() {
      //     console.log(this);
      //   }
      //   函数名();
      //   fn();

      //   2. 方法调用模式 this ==> 调用方法的对象
      let f = function () {
        console.log(this);
      };
      //   let obj = {
      //     abc: "abc",
      //     fn: f,
      //   };
      //   对象.方法名() 对象['对象名']()
      //   obj.fn();
      //   obj["fn"]();

      //   点语法, 中括号来访问对象的方法 都是属于方法调用模式

      //   let arr = [f, 10, 20];
      //   arr[0]();

      // 上面的this这么去理解
      // var arr = {0: f, 1: 10, 2: 20};
      // arr[0]();

      //   3.构造函数模式 ==> this ==> 实例对象
      //   function Person() {
      //     console.log(this);
      //   }
      //   let p = new Person();

      //   4.上下文模式  -- 方法借用模式
      //  call apply bind
      // 任何函数度可以调用这个三个方法

      // call
      // 1. call能够调用函数
      // function fn() {
      //   console.log(1);
      // }
      // fn();
      // fn.call();

      // 2. call可以改变函数内的this的指向
      // function fn() {
      //   console.log(this);
      // }
      // fn.call({ name: "zs" });

      // 3. call的参数是若干个 除了第一个参数外 其他的参数都是作为函数的实参
      // function fn(n1, n2) {
      //   console.log(this);
      //   console.log(n1 + n2);
      // }
      // fn.call({ name: "zs" }, 10, 20);

      // 4.如果call在调用的时候,没有传递任何参数 , 或者就传递嗯呢null/undefined name函数内的this的指向为window的(了解)
      // function fn() {
      //   console.log(this);
      // }
      // fn.call(undefined);
      // fn.call(null);
    </script>
  </body>
</html>
